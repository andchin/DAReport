# transformDataFrame function
powerTransform.eh = function(X) {
tryCatch(powerTransform(X), error=function(e) NULL)
}
transformDataFrame = function(data) {
data.lambda = apply(data, 2, powerTransform.eh)
data.t = data
for(name in colnames(data.t)) {
if(is.null(data.lambda[[name]])) {
col = rep(NA, length(data.t[,1]))
}
else {
col = boxcox(data[[name]], data.lambda[[name]][["lambda"]])
}
data.t[[name]] = col
}
return(data.t)
}
# Load Package mlbench and Glass-Dataset
library(mlbench)
data(Glass)
# Define Significance-Level
sign.lvl <- 0.01
# Define different Subdatasets for the different Glass Types
Glass.type1 = Glass[which(Glass$Type == 1), -10]
Glass.type2 = Glass[which(Glass$Type == 2), -10]
Glass.type3 = Glass[which(Glass$Type == 3), -10]
Glass.type5 = Glass[which(Glass$Type == 5), -10]
Glass.type6 = Glass[which(Glass$Type == 6), -10]
Glass.type7 = Glass[which(Glass$Type == 7), -10]
# QQ-Plots for each Element in each Glass Type
layout(matrix(1:4, ncol=2,nrow=2))
sapply(colnames(Glass.type1), function(x) {
qqnorm(Glass.type1[[x]], main = x,pch=19,
cex.lab=2,cex.main=2,ylab=" ")
qqline(Glass.type1[[x]],lwd=2,col="red")
})
layout(matrix(1:4, ncol=2,nrow=2))
sapply(colnames(Glass.type2), function(x) {
qqnorm(Glass.type2[[x]], main = x,pch=19,
cex.lab=2,cex.main=2,ylab=" ")
qqline(Glass.type2[[x]],lwd=2,col="red")
})
layout(matrix(1:4, ncol=2,nrow=2))
sapply(colnames(Glass.type3), function(x) {
qqnorm(Glass.type3[[x]], main = x,pch=19,
cex.lab=2,cex.main=2,ylab=" ")
qqline(Glass.type3[[x]],lwd=2,col="red")
})
layout(matrix(1:4, ncol=2,nrow=2))
sapply(colnames(Glass.type5), function(x) {
qqnorm(Glass.type5[[x]], main = x,pch=19,
cex.lab=2,cex.main=2,ylab=" ")
qqline(Glass.type5[[x]],lwd=2,col="red")
})
layout(matrix(1:4, ncol=2,nrow=2))
sapply(colnames(Glass.type6), function(x) {
qqnorm(Glass.type6[[x]], main = x,pch=19,
cex.lab=2,cex.main=2,ylab=" ")
qqline(Glass.type6[[x]],lwd=2,col="red")
})
layout(matrix(1:4, ncol=2,nrow=2))
sapply(colnames(Glass.type7), function(x) {
qqnorm(Glass.type7[[x]], main = x,pch=19,
cex.lab=2,cex.main=2,ylab=" ")
qqline(Glass.type7[[x]],lwd=2,col="red")
})
# Shapiro-Wilk-Test for Glass Type 1
apply(Glass.type1, 2, shapiro.test)
shapiro.test.eh <- function(x) {
tryCatch(shapiro.text(x), error=function(e) NA)
}
# Isolating the P-Values and checking for Significance-Levels
# shapresult.type1$RI$statistic
# str(shapresult.type1$RI)
# names(shapresult.type1)
# shapresult.type1$dataname
shapresult.type1 <- apply(Glass.type1, 2, shapiro.test)
shapresult.type1[["RI"]][["statistic"]]
which(shapresult.type1 >= sign.lvl)
shapresult.type2 <- apply(Glass.type2, 2, shapiro.test)
shapresult.type2[["RI"]][["statistic"]]
which(shapresult.type2 >= sign.lvl)
shapresult.type3 <- apply(Glass.type3, 2, shapiro.test)
shapresult.type3[["RI"]][["statistic"]]
which(shapresult.type3 >= sign.lvl)
shapresult.type5 <- apply(Glass.type5, 2, shapiro.test)
shapresult.type5[["RI"]][["statistic"]]
which(shapresult.type5 >= sign.lvl)
shapresult.type6 <- apply(Glass.type6, 2, shapiro.test)
shapresult.type6[["RI"]][["statistic"]]
which(shapresult.type6 >= sign.lvl)
shapresult.type7 <- apply(Glass.type7, 2, shapiro.test)
shapresult.type7[["RI"]][["statistic"]]
which(shapresult.type7 >= sign.lvl)
### Chi squared test ###
# Calculates bounds of bins (classes) of a data sample.
# The initial bounds are given by initial_breaks, k denotes the minimum class size.
makebins = function(data, initial_breaks, k) {
h = hist(data, breaks=initial_breaks, plot=FALSE)
br = h$breaks
changed = TRUE
while(changed) {
h = hist(data, breaks=br, plot=FALSE)
br = h$breaks
changed=FALSE
for(i in 1:length(h$counts)) {
if(h$counts[i] < k) {
if(i > 1 && i < length(h$counts)) {
if(h$counts[i-1] < h$counts[i+1]) {
br = br[-i]
changed = TRUE
break
}
else {
br = br[-(i+1)]
changed = TRUE
break
}
}
# index on first class
else if(i == 1) {
br = br[-2]
changed = TRUE
break
}
# index on last class
else {
br = br[-(length(h$counts))]
changed = TRUE
break
}
}
}
}
return(br)
}
# Calculates the expected probabilities of a normal distribution with the given parameters mean and sd
# for the given bin (class) bounds
probabilities.exp = function(bins, mean, sd) {
result = rep(0, length(bins)-1)
result[1] = pnorm(q=bins[2], mean=mean, sd=sd)
for(i in 2:(length(bins)-1)) {
result[i] <- pnorm(q=bins[i+1], mean=mean, sd=sd) - pnorm(q=bins[i], mean=mean, sd=sd)
}
result[length(bins)-1] = pnorm(q=bins[length(bins)-1], mean=mean, sd=sd, lower.tail=FALSE)
return(result)
}
# Returns the chi squared test statistics for the given actual and expected values.
teststat.chi = function(actual, expected) {
sum((actual - expected)^2 / expected)
}
# Performs a chi squared goodness of fit test on the given data for the assumption of a normal distribution.
# The parameters are estimated from the sample.
# The initial bounds for the classes are given by initial_breaks, min denotes the minimum class size.
# The significance level is determined by sig.
chisq.test.norm = function(data, initial_breaks, min, sig) {
bins = makebins(data, initial_breaks, min)
hist = hist(data, breaks=bins, plot=FALSE)
expected_probabilities = probabilities.exp(bins, mean(data), sd(data))
expected_frequencies = expected_probabilities * length(data)
teststat = teststat.chi(hist$counts, expected_frequencies)
critical_value = qchisq(p=1-sig, df=length(bins)-4) # df: length(bin) - 1 classes, 2 estimated parameters (mean, sd)
print(teststat > critical_value)
return(list(hist = hist,
expected_probabilities = expected_probabilities,
expected_frequencies = expected_frequencies,
teststat = teststat,
critical_value = critical_value,
p_value = 1 - pchisq(q=teststat, df=length(bins)-4),
rejected = teststat > critical_value))
}
# Returns class centers (mids) for given breaks.
getMids = function(breaks) {
mids = rep(0, length(breaks)-1)
for(i in 1:(length(breaks)-1)) {
mids[i] = (breaks[i+1] + breaks[i]) / 2
}
return(mids)
}
# Creates artificial data from expected frequencies as input for hist().
# testresult is the result of chisq.test.norm.
# mult is the factor by which the frequencies are multiplied (to increase accuracy
# after rounding and casting to integer).
dataFromFreq = function(testresult, mult) {
x = testresult$expected_frequencies
mids = getMids(testresult$hist$breaks)
freqs = as.integer(round(mult*x))
result = rep(0, sum(freqs))
counter = 1
for(i in 1:length(freqs)) {
for(j in 1:freqs[i]) {
result[counter] = mids[i]
counter = counter + 1
}
}
return(result)
}
# Returns a histogram of the expected frequencies from testresult (result of chisq.test.norm).
# Does not plot the histogram.
histFromExpectedFreqs = function(testresult) {
hist(dataFromFreq(testresult, 1000), breaks=testresult$hist$breaks, freq=FALSE, plot=FALSE)
}
require(mlbench)
data(Glass)
Glass.type1 = Glass[which(Glass$Type == 1), -10]
Glass.type2 = Glass[which(Glass$Type == 2), -10]
Glass.type3 = Glass[which(Glass$Type == 3), -10]
Glass.type5 = Glass[which(Glass$Type == 5), -10]
Glass.type6 = Glass[which(Glass$Type == 6), -10]
Glass.type7 = Glass[which(Glass$Type == 7), -10]
testres = chisq.test.norm(Glass.type1$Na, 10, 5, 0.01)
testres
par(mfrow=c(2,2))
hist=testres$hist
plot(hist, col=rgb(1, 0, 0,0.5))
hist.exp=histFromExpectedFreqs(testres)
plot(hist.exp, col=rgb(0, 0, 1,0.5))
plot(hist, col=rgb(1, 0, 0,0.5))
plot(hist.exp, col=rgb(0, 0, 1,0.5), add=TRUE)
par(mfrow=c(1,1))
apply(Glass[-10], 2, chisq.test.norm, initial_breaks=30, min=5, sig=0.01)
Glass.type1.t <- transformDataFrame(Glass.type1)
Glass.type1.t
Glass.type1
